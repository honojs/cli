import type { Command } from 'commander'
import * as esbuild from 'esbuild'
import type { Hono } from 'hono'
import { buildInitParams, serializeInitParams } from 'hono/router/reg-exp-router'
import type { RouterRoute } from 'hono/types'
import { execFile } from 'node:child_process'
import { writeFileSync, existsSync, realpathSync } from 'node:fs'
import { resolve, extname, dirname } from 'node:path'
import { pathToFileURL } from 'node:url'

const BANNER = '// This file is generated by `hono optimize`'
const DEFAULT_ENTRY_CANDIDATES = ['src/index.ts', 'src/index.tsx', 'src/index.js', 'src/index.jsx']

export function optimizeCommand(program: Command) {
  program
    .command('optimize')
    .description('Build optimized Hono class')
    .argument('[entry...]', 'entry files')
    .option('-o, --outfile [outfile]', 'output file')
    .action(async (entries: string[], options: { outfile?: string }) => {
      if (!entries?.length) {
        entries = [
          DEFAULT_ENTRY_CANDIDATES.find((entry) => existsSync(resolve(process.cwd(), entry))) ??
            DEFAULT_ENTRY_CANDIDATES[0],
        ]
      }

      const mainEntry = entries[0]
      const mainExt = extname(mainEntry)
      const mainAppPath = resolve(process.cwd(), mainEntry)
      const outfile = options.outfile
        ? resolve(process.cwd(), options.outfile)
        : resolve(dirname(mainAppPath), `hono-optimized${mainExt.replace(/x$/, '')}`)

      const routes: RouterRoute[] = []
      for (const entry of entries) {
        const ext = extname(entry)
        const appPath = resolve(process.cwd(), entry)

        if (!existsSync(appPath)) {
          throw new Error(`Entry file ${entry} does not exist`)
        }

        let app: Hono

        const appFilePath = realpathSync(appPath)
        // TypeScript/JSX files need transformation and bundling
        if (['.ts', '.tsx', '.jsx'].includes(ext)) {
          // Use build API to resolve imports and bundle
          const result = await esbuild.build({
            entryPoints: [appFilePath],
            bundle: true,
            write: false,
            format: 'esm',
            target: 'node20',
            jsx: 'automatic',
            jsxImportSource: 'hono/jsx',
            platform: 'node',
            external: ['@hono/node-server'], // Keep server external
          })

          // Execute the bundled code using data URL
          const code = result.outputFiles[0].text
          const dataUrl = `data:text/javascript;base64,${Buffer.from(code).toString('base64')}`
          const module = await import(dataUrl)
          app = module.default
        } else {
          // Regular JS files can be imported directly
          const module = await import(pathToFileURL(appFilePath).href)
          app = module.default
        }

        routes.push(...app.routes)
      }

      let importStatement
      let assignRouterStatement
      try {
        const serialized = serializeInitParams(
          buildInitParams({
            paths: routes.map(({ path }) => path),
          })
        )

        const hasPreparedRegExpRouter = await new Promise<boolean>((resolve) => {
          const child = execFile(process.execPath, [
            '--input-type=module',
            '-e',
            "try { (await import('hono/router/reg-exp-router')).PreparedRegExpRouter && process.exit(0) } finally { process.exit(1) }",
          ])
          child.on('exit', (code) => {
            resolve(code === 0)
          })
        })

        if (hasPreparedRegExpRouter) {
          importStatement = "import { PreparedRegExpRouter } from 'hono/router/reg-exp-router'"
          if (['.ts', '.tsx'].includes(mainExt)) {
            assignRouterStatement = `const routerParams = ${serialized} as unknown as ConstructorParameters<typeof PreparedRegExpRouter>
    this.router = new PreparedRegExpRouter(...routerParams) as unknown as typeof this.router`
          } else {
            assignRouterStatement = `this.router = new PreparedTrieRouter(...${serialized})`
          }
        } else {
          importStatement = "import { RegExpRouter } from 'hono/router/reg-exp-router'"
          assignRouterStatement = 'this.router = new RegExpRouter()'
        }
      } catch {
        // fallback to default router
        importStatement = "import { TrieRouter } from 'hono/router/trie-router'"
        assignRouterStatement = 'this.router = new TrieRouter()'
      }

      if (['.ts', '.tsx'].includes(mainExt)) {
        writeFileSync(
          outfile,
          `${BANNER}
import { HonoBase } from 'hono/hono-base'
import type { HonoOptions } from 'hono/hono-base'
${importStatement}
import type { BlankEnv, BlankSchema, Env, Schema } from 'hono/types'

export class Hono<
  E extends Env = BlankEnv,
  S extends Schema = BlankSchema,
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    ${assignRouterStatement}
  }
}
`
        )
      } else {
        writeFileSync(
          outfile,
          `${BANNER}
import { HonoBase } from 'hono/hono-base'
${importStatement}

export class Hono extends HonoBase {
  constructor(options = {}) {
    super(options)
    ${assignRouterStatement}
  }
}
`
        )
      }
    })
}
